Step by Step guide
#1. Requirements clarifications
#2 Back-of-the-envelope estimation
#3 System Interface definition
#4 Defining data model
#5 High-level design
#6 Detailed design
#7 Identifying and resolving bottlenecks


Reasons for SQL:
  1. Structured Data, 2. Strict Schema, 3. Relational data, 4. Need for complex joins, 
  5. Transactions 6. Clear patterns for scaling, 7. More established: developers, community, code, tools, etc
  8. Lookups by index are very fast

Reasons for NoSQL:
  1. Semi-structured data 2. Dynamic or flexible schema, 3. Non-relational data 4. No need for complex joins. 5. Store many TB or PB of data
  6. Very data intensive workload 7. Very high throughput for IOPS
  Sample data well-suited for NoSQL:
    Rapid ingest of clickstream and log data
    Leaderboard or scroing data
    Temporary data, such as a shopping cart
    Frequently accessed ('hot') tables
    Metadat/ lookup tables

High level differences between SQL and NoSQL

Storage: SQL stores data in tables, where each row represents an entity, and each column represents a data point about that entity. For example,
if we are stroing a car entity in a table, different columns could be 'color', 'make'. 'model', and so on.

NoSQL data bases have different data storage models. The main ones are key-value, document, graph, and columnar.

Schema: In SQL, each record conforms to a fixed schema, meaning the columns must be decided and chosen before data entry and each row must have data for each column.
The schema can be altered later, but it involves modifying the whole database and going offline

Whereas in NoSQl, schemas are dynamic. Columns can be added on the fly, and each 'row' (or equivalent) doesn't have to contain data for each column

Querying: SQL databases uses SQL (structured query language) for defining and manipulating the data, which is very powerful. In NoSQL database, queries are focused on a collection 
of documents. Sometimes it is also called UNQL (Unstructured Query Language) Different databases have different syntax for using UnQL

Scalability： In most common situations, SQL DB are vertically scalable, by increasing the hardware (expensive). It is possible to scale a relational DB across multiple servers
but it is challenging and time-consuming process.

NoSQL DB is horizontally scalable, meaning we can add more servers easily in our NoSQL DB infrastructure to handle large traffic. 

Reliability or ACID (Automicity, Consistency, Isolation, Durability): When it comes to data reliability and safe guarantee of performing transactions, SQL is the better bet.


Polling VS. Push
Problem with Pooling is that the client has to keep asking the server for any new data. As a result, a lot of responses are empty creating HTTP overhead 

Websockets: full duplex. allows communication between both direction simultaneously over a single TCP connection. 



### TinyURL example

# Goals and Requirements of the System

Functional Requirements:
Given a URL, our service should generate a shorter and unique alias of it. This is called a short link. This link should be short enough to be easily copied and pasted into applications.
When users access a short link, our service should redirect them to the original link.
Users should optionally be able to pick a custom short link for their URL.
Links will expire after a standard default timespan. Users should be able to specify the expiration time.

Non-Functional Requirements:
The system should be highly available. This is required because, if our service is down, all the URL redirections will start failing.
URL redirection should happen in real-time with minimal latency.
Shortened links should not be guessable (not predictable).


Extended Requirements:
Analytics; e.g., how many times a redirection happened?
Our service should also be accessible through REST APIs by other services.


#Capacity Estimation and Constraints

Assuming 100:1 read and write ratio
Traffic Estimation: 
say 500 M new URL shrotenings permonth, 100:1 read/write ration:  100*500 M == 50 B
QPS (queries Per Second) 500 M / (30 days * 24 hours * 3600 seconds) = ~200 URLs/s   for write
100 * 200 URLs/s = 20k URLs/s for read

Storage Estimation:
Let’s assume we store every URL shortening request (and associated shortened link) for 5 years. 
Since we expect to have 500M new URLs every month, the total number of objects we expect to store will be 30 billion:

500 M * 5 Years * 12 Months = 30 B  if each is 500 bytes then the total storage --> 15 TB

Bandwidth estimates:

For write requests, since we expect 200 new URLs every second, total incoming data for our service will be 100KB per second:
200 URLs/s * 500 bytes = 100 KB/s

For read requests, since every second we expect ~20K URLs redirections, total outgoing data for our service would be 10MB per second
20K * 500 bytes = 10 MB/s

Memory estimates:






















