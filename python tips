1). Use enumerate instead of range(len(x)) for iteration
2). Use list comprehension instead of raw for loops
3). sort complex iterables with sorted()
  ex. 
  data = [{'name': 'Max', 'age': 6},{'name': 'Lisa', 'age': 20}, {'name': 'Max', 'age': 9}]
  sorted_data = sorted(data, ket = lambda x : x['age'])
4). Store unique values with Sets
5). Save memory with generators
  import sys
  my_list = [i for i in range(10000)]
  print(sum(my_list))
  print(sys.getsizeof(my_list), 'bytes')
  ### 87632 bytes
  
  my_gen = (i for i in range(10000))
  print(sum(my_gen))
  print(sys.getsizeof(my_gen), 'bytes')
  ### 128 bytes
  
6). Define default values in Dictionaries with .get() and .setdefault()
   my_dict = {'item': 'football', 'price': 10}
   count = my_dict.get('count', 0)  ## if count variable is not in my_dict and we don't specify 0 then it would return None
   
   count = my_dict.setdefault('count',0)
   ## It would show in my_dict as 'count':0

7). Count hashable objects with collections.Counter
  my_list = [10,10,10,5,5,5,2,2,2,]
  counter = collections.Counter(my_list)
  
  # you can also find the most common item
  most_common = counter.most_common(1)  ## if it is 2, then the most 2 common items

8). Format strings with f-strings
  name = 'Alex'
  my_string = f'Hello {name}'
  print(my_string)
  
  i = 10
  print(f'{i} squared is {i*i}')

9). Concatenate Strings with .join()
  list_of_string = {'hello', 'my', 'friend'}
  my_string = ' '.join(list_of_strings)
  
10). Merge dictionaries with {**d1, **d2} (python 3.5 +)
  d1 = {'name':'Alex', 'age': 25}
  d2 = {'name':'Alex', 'city': 'New York'}
  merged_dict = {**d1, **d2}
  print(merged_dict)  ## {'name':'Alex', 'age': 25, 'city': 'New York'}
  
11). Simplify if-statement with if x in [a,b,c]
  
  
num1 = 10_000_000_000
num2 = 100_000_000
total = num1 + num2
print(f'{total:,}')
##output would be 10,100,000,000

instead of open() close()
we can directly
with open('test.txt', 'r') as f:
  file_contents = f.read()
  

### Iterators and Iterables

a list is iterable
nums = [1,2,3]
for num in nums:
  print(num)

how can we tell a thing is iterable
__iter__()
print(dir(nums)) ###---> it would show '__iter__' in it means it is iterable
print(next(nums)) ###---> 'list' is not an iterator

i_nums = nums.__iter__()
#or
i_nums = iter(nums)
print(i_nums)
print(dir(i_nums))
print(next(i_nums))   ## 1 if we do it again and it will show 2 again it will be 3

class MyRange:
    def __init__(self, start,end):
        self.value = start
        self.end = end
    def __iter__(self):
        return self
    def __next__(self):
        if self.value >= self.end:
            raise StopIteration
        current = self.value
        self.value += 1
        return current

nums = MyRange(1,10)
print(next(nums))   ## 1


## Generators function can be not in a class
def my_range(start, end):
  current = start
  while current < end:
    yield current
    current += 1
nums = my_range(1,10)









  
  
  
  
  
  
  
